import { Location, Gray } from './kanoodle.js';

// Helper functions
function applyMirrorX(offset, mirrorX) {
    return mirrorX ? new Location(offset.x + offset.y, -offset.y, offset.z) : offset;
}

function applyLean(offset, lean) {
    return lean ? new Location(offset.x, 0, offset.y) : offset;
}

function rotateOffset(location, rotation) {
    if (rotation === 0) return location;
    let r = new Location(location.x, location.y, location.z);
    for (let i = 0; i < rotation; i++) {
        r = new Location(-r.y, r.x + r.y, r.z);
    }
    return r;
}

function transposeToPlane(plane, origin) {
    if (plane === 0) return origin;
    else if (plane === 1) return new Location(5 - (origin.x + origin.y + origin.z), origin.x, origin.z);
    else if (plane === 2) return new Location(origin.y, 5 - (origin.x + origin.y + origin.z), origin.z);
    throw new Error('Plane must be between 0 and 2');
}

function positionToBit(x, y, z) {
    return BigInt(x * 36 + y * 6 + z);
}

function isValidPosition(x, y, z) {
    return x >= 0 && y >= 0 && z >= 0 && (x + y + z) <= 5;
}

function getPositionMask(positions) {
    let mask = 0n;
    for (const pos of positions) {
        if (isValidPosition(pos.x, pos.y, pos.z)) {
            const bit = positionToBit(pos.x, pos.y, pos.z);
            mask |= (1n << bit);
        }
    }
    return mask;
}

console.log('='.repeat(70));
console.log('ANALYZING: Mathematical Relationship Between Lean and Planes');
console.log('='.repeat(70));

console.log('\nTesting specific example:');
console.log('Gray piece node (0,1,0) at root (1,1,0)');

const node = new Location(0, 1, 0);
const root = new Location(1, 1, 0);

console.log('\nScenario 1: Flat (no lean), Plane 0');
const flatPlaced = new Location(root.x + node.x, root.y + node.y, root.z + node.z);
const flatPlane0 = transposeToPlane(0, flatPlaced);
console.log(`  Node: (${node.x}, ${node.y}, ${node.z})`);
console.log(`  Root: (${root.x}, ${root.y}, ${root.z})`);
console.log(`  Placed: (${flatPlaced.x}, ${flatPlaced.y}, ${flatPlaced.z}) = root + node`);
console.log(`  Plane 0: (${flatPlane0.x}, ${flatPlane0.y}, ${flatPlane0.z})`);

console.log('\nScenario 2: With Lean, Plane 0');
const leaned = applyLean(node, true);
const leanedPlaced = new Location(root.x + leaned.x, root.y + leaned.y, root.z + leaned.z);
const leanedPlane0 = transposeToPlane(0, leanedPlaced);
console.log(`  Lean transform: (${node.x}, ${node.y}, ${node.z}) -> (${leaned.x}, ${leaned.y}, ${leaned.z})`);
console.log(`  Placed: (${leanedPlaced.x}, ${leanedPlaced.y}, ${leanedPlaced.z}) = root + leaned`);
console.log(`  Plane 0: (${leanedPlane0.x}, ${leanedPlane0.y}, ${leanedPlane0.z})`);

console.log('\nScenario 3: Flat (no lean), Plane 1');
const flatPlane1 = transposeToPlane(1, flatPlaced);
console.log(`  Same placed as Scenario 1: (${flatPlaced.x}, ${flatPlaced.y}, ${flatPlaced.z})`);
console.log(`  Plane 1 transform: (5-${flatPlaced.x + flatPlaced.y + flatPlaced.z}, ${flatPlaced.x}, ${flatPlaced.z})`);
console.log(`  Plane 1: (${flatPlane1.x}, ${flatPlane1.y}, ${flatPlane1.z})`);

console.log('\nScenario 4: Flat (no lean), Plane 2');
const flatPlane2 = transposeToPlane(2, flatPlaced);
console.log(`  Same placed as Scenario 1: (${flatPlaced.x}, ${flatPlaced.y}, ${flatPlaced.z})`);
console.log(`  Plane 2 transform: (${flatPlaced.y}, 5-${flatPlaced.x + flatPlaced.y + flatPlaced.z}, ${flatPlaced.z})`);
console.log(`  Plane 2: (${flatPlane2.x}, ${flatPlane2.y}, ${flatPlane2.z})`);

console.log('\n' + '='.repeat(70));
console.log('COMPARISON:');
console.log('='.repeat(70));
console.log(`Leaned Plane 0: (${leanedPlane0.x}, ${leanedPlane0.y}, ${leanedPlane0.z})`);
console.log(`Flat Plane 0:    (${flatPlane0.x}, ${flatPlane0.y}, ${flatPlane0.z})`);
console.log(`Flat Plane 1:    (${flatPlane1.x}, ${flatPlane1.y}, ${flatPlane1.z})`);
console.log(`Flat Plane 2:    (${flatPlane2.x}, ${flatPlane2.y}, ${flatPlane2.z})`);

const match1 = leanedPlane0.x === flatPlane0.x && leanedPlane0.y === flatPlane0.y && leanedPlane0.z === flatPlane0.z;
const match2 = leanedPlane0.x === flatPlane1.x && leanedPlane0.y === flatPlane1.y && leanedPlane0.z === flatPlane1.z;
const match3 = leanedPlane0.x === flatPlane2.x && leanedPlane0.y === flatPlane2.y && leanedPlane0.z === flatPlane2.z;

console.log(`\nMatches:`);
console.log(`  Leaned Plane 0 == Flat Plane 0: ${match1 ? 'YES' : 'NO'}`);
console.log(`  Leaned Plane 0 == Flat Plane 1: ${match2 ? 'YES' : 'NO'}`);
console.log(`  Leaned Plane 0 == Flat Plane 2: ${match3 ? 'YES' : 'NO'}`);

console.log('\n' + '='.repeat(70));
console.log('CONCLUSION:');
console.log('='.repeat(70));
if (match1 || match2 || match3) {
    console.log('✓ Lean can be replaced by a plane transform!');
    if (match1) console.log('  → Lean = Flat on Plane 0');
    if (match2) console.log('  → Lean = Flat on Plane 1');
    if (match3) console.log('  → Lean = Flat on Plane 2');
} else {
    console.log('✗ Lean produces unique positions that cannot be generated by plane transforms alone');
    console.log('\nThe transformations are fundamentally different:');
    console.log('  • Lean: Transforms the PIECE before placement (piece orientation changes)');
    console.log('  • Plane: Transforms the BOARD after placement (coordinate system changes)');
    console.log('\nThese operate on different stages of the transformation pipeline,');
    console.log('so they cannot be equivalent.');
}

